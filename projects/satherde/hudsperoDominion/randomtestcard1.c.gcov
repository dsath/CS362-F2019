        -:    0:Source:randomtestcard1.c
        -:    0:Graph:randomtestcard1.gcno
        -:    0:Data:randomtestcard1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:///////////////////////////////////////////
        -:    2:// Baron Unit Tests
        -:    3://////////////////////////////////////////
        -:    4:
        -:    5:
        -:    6://int baron_func(struct gameState *state, int currentPlayer, int choice1);
        -:    7:
        -:    8:#include <stdio.h> 
        -:    9:#include <string.h> 
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include "rngs.h"
        -:   15:
        -:   16://int baron_func_test(struct gameState *state, int currentPlayer, int choice1); 
        -:   17:struct gameState* randomGameState();
        -:   18:
        -:   19:
        -:   20:int playBaron_test(int choice1, struct gameState *state, int handPos); 
        -:   21:
        -:   22:
        -:   23:
function main called 1 returned 100% blocks executed 100%
        1:   24:int main() {
        1:   25:	int k[10] = { adventurer, council_room, feast, gardens, mine
        -:   26:	, remodel, smithy, village, baron, great_hall };
        -:   27:	struct gameState G;
        -:   28:	int
        -:   29:	coppers[MAX_HAND];
        -:   30:	int
        -:   31:	silvers[MAX_HAND];
        -:   32:	int
        -:   33:	golds[MAX_HAND];
        1:   34:	memset(&G, 0, sizeof(struct gameState));
        -:   35:	
        1:   36:	int i = 0;
        1:   37:	int j = 0;
     1001:   38:	for( i = 0; i < 1000; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   39:
     1000:   40:		initializeGame(rand() % 5, k, rand(), &G);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1001000:   41:		for( j = 0; j < 1000; j++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   42:			//baron_func_test(&G, rand() % 5, rand() % 3);
  1000000:   43:			playBaron_test(rand() % 3, &G, rand() % 5);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   44:		}
        -:   45:	}
        -:   46:
        1:   47:	return 0;
        -:   48:}
        -:   49:
        -:   50:/*
        -:   51:struct gameState* randomGameState() {
        -:   52:	int i = 0;
        -:   53:	struct gameState *t = malloc(sizeof(struct gameState));
        -:   54:	t->numPlayers = rand() % 4;
        -:   55:	for( i = 0; i < treasure_map + 1; i ++) {
        -:   56:		t->supplyCount[i] = rand() % 15;
        -:   57:	}
        -:   58:	for( i = 0; i < treasure_map + 1; i ++) {
        -:   59:		t->embargoTokens[i] = rand() % 15;
        -:   60:	}
        -:   61:	t->outpostPlayed = rand() % 4;
        -:   62:	t->outpostTurn = rand() % 4;
        -:   63:	t->whoseTurn = rand() % 4;
        -:   64:	t->phase = rand() % 4;
        -:   65:	t->numActions = rand() % 4;
        -:   66:	t->coins = rand() % 4;
        -:   67:	t->numBuys = rand() % 4;
        -:   68:
        -:   69:}
        -:   70:*/
        -:   71:/*
        -:   72:int baron_func_test(struct gameState *state, int currentPlayer, int choice1) {
        -:   73:	state->numBuys++;//Increase buys by 1!
        -:   74:	if (choice1 > 0) { //Boolean true or going to discard an estate
        -:   75:	    //int p = 2;//Iterator for hand!
        -:   76:	    int p = 0;//Iterator for hand!
        -:   77:	    int card_not_discarded = 1;//Flag for discard set!
        -:   78:	    while(card_not_discarded) {
        -:   79:		if (state->hand[currentPlayer][p] == estate) { //Found an estate card!
        -:   80:		    state->coins += 4;//Add 4 coins to the amount of coins
        -:   81:		    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        -:   82:		    state->discardCount[currentPlayer]++;
        -:   83:		    for (; p < state->handCount[currentPlayer]; p++) {
        -:   84:			state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:   85:		    }
        -:   86:		    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        -:   87:		    state->handCount[currentPlayer]--;
        -:   88:		    //card_not_discarded = 1;//Exit the loop
        -:   89:		    card_not_discarded = 0;//Exit the loop
        -:   90:		}
        -:   91:		else if (p > state->handCount[currentPlayer]) {
        -:   92:		    if(DEBUG) {
        -:   93:			printf("No estate cards in your hand, invalid choice\n");
        -:   94:			printf("Must gain an estate if there are any\n");
        -:   95:		    }
        -:   96:		    if (supplyCount(estate, state) > 0) {
        -:   97:			gainCard(estate, state, 0, currentPlayer);
        -:   98:
        -:   99:			state->supplyCount[estate]--;//Decrement estates
        -:  100:			if (supplyCount(estate, state) == 0) {
        -:  101:			    isGameOver(state);
        -:  102:			}
        -:  103:		    }
        -:  104:		    card_not_discarded = 0;//Exit the loop
        -:  105:		}
        -:  106:
        -:  107:		else {
        -:  108:		    p++;//Next card
        -:  109:		}
        -:  110:	    }
        -:  111:	}
        -:  112:
        -:  113:	else {
        -:  114:	    if (supplyCount(estate, state) > 0) {
        -:  115:		gainCard(estate, state, 0, currentPlayer);//Gain an estate
        -:  116:
        -:  117:		state->supplyCount[estate]--;//Decrement Estates
        -:  118:		if (supplyCount(estate, state) == 0) {
        -:  119:		    isGameOver(state);
        -:  120:		}
        -:  121:	    }
        -:  122:	}
        -:  123:	return 0;
        -:  124:}
        -:  125:
        -:  126:*/
        -:  127:
function playBaron_test called 1000000 returned 100% blocks executed 85%
  1000000:  128:int playBaron_test(int choice1, struct gameState *state, int handPos) {
  1000000:  129:	int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  130:	
  1000000:  131:	state->numBuys++;//Increase buys by 1!
  1000000:  132:	if (choice1 > 0) { //Boolean true or going to discard an estate
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
   667082:  133:		int p = 0;//Iterator for hand!
   667082:  134:		int card_not_discarded = 1;//Flag for discard set!
  4725709:  135:		while(card_not_discarded) {
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
  3391545:  136:			if (state->hand[currentPlayer][p] == estate) { //Found an estate card!
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      890:  137:				state->coins += 4;//Add 4 coins to the amount of coins
      890:  138:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
      890:  139:				state->discardCount[currentPlayer]++;
     1899:  140:				for (; p < state->handCount[currentPlayer]; p++) {
branch  0 taken 53%
branch  1 taken 47% (fallthrough)
     1009:  141:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  142:				}
      890:  143:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
      890:  144:				state->handCount[currentPlayer]--;
      890:  145:				card_not_discarded = 0;//Exit the loop
        -:  146:			}
  3390655:  147:			else if (p < state->handCount[currentPlayer]) { //BUG! Should be >
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  148:				if(DEBUG) {
        -:  149:					printf("No estate cards in your hand, invalid choice\n");
        -:  150:					printf("Must gain an estate if there are any\n");
        -:  151:				}
   666192:  152:				if (supplyCount(estate, state) < 0) { //BUG! Should be > 0
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  153:					gainCard(estate, state, 0, currentPlayer);
call    0 never executed
        -:  154:
    #####:  155:					state->supplyCount[estate]--;//Decrement estates
    #####:  156:					if (supplyCount(estate, state) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  157:						isGameOver(state);
call    0 never executed
        -:  158:					}
        -:  159:				}
   666192:  160:				card_not_discarded = 0;//Exit the loop
        -:  161:			}
        -:  162:
        -:  163:			else {
  2724463:  164:				p++;//Next card
        -:  165:			}
        -:  166:		}
        -:  167:	}
        -:  168:	
        -:  169:	else {
   332918:  170:		if (supplyCount(estate, state) > 0) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
     3194:  171:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 returned 100%
        -:  172:
     3194:  173:			state->supplyCount[estate]--;//Decrement Estates
     3194:  174:			if (supplyCount(estate, state) == 0) {
call    0 returned 100%
branch  1 taken 19% (fallthrough)
branch  2 taken 81%
      599:  175:				isGameOver(state);
call    0 returned 100%
        -:  176:			}
        -:  177:		}
        -:  178:	}
        -:  179:
  1000000:  180:	return 0;
        -:  181:}
        -:  182:
