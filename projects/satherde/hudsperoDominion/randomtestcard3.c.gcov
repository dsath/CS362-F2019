        -:    0:Source:randomtestcard3.c
        -:    0:Graph:randomtestcard3.gcno
        -:    0:Data:randomtestcard3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:///////////////////////////////////////////
        -:    2:// Baron Unit Tests
        -:    3://////////////////////////////////////////
        -:    4:
        -:    5:
        -:    6://int baron_func(struct gameState *state, int currentPlayer, int choice1);
        -:    7:
        -:    8:#include <stdio.h> 
        -:    9:#include <string.h> 
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include "rngs.h"
        -:   15:
        -:   16:
        -:   17://int tribute_func_test(struct gameState *state, int currentPlayer, int nextPlayer, int *tributeRevealedCards); 
        -:   18:int playTribute_test(struct gameState *state, int handPos); 
        -:   19:
function main called 1 returned 100% blocks executed 100%
        1:   20:int main() {
        1:   21:	int k[10] = { adventurer, council_room, feast, gardens, mine
        -:   22:	, remodel, smithy, village, baron, great_hall };
        -:   23:	struct gameState G;
        -:   24:	int
        -:   25:	coppers[MAX_HAND];
        -:   26:	int
        -:   27:	silvers[MAX_HAND];
        -:   28:	int
        -:   29:	golds[MAX_HAND];
        1:   30:	memset(&G, 0, sizeof(struct gameState));
        -:   31:	
        1:   32:	int i = 0;
        1:   33:	int j = 0;
     1001:   34:	for( i = 0; i < 1000; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   35:
     1000:   36:		initializeGame(2, k, rand(), &G);
call    0 returned 100%
call    1 returned 100%
  1001000:   37:		for( j = 0; j < 1000; j++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  1000000:   38:			if(rand() % 100 == 2) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
     9945:   39:				G.deckCount[1] = 0;
        -:   40:			}
  1000000:   41:			int tributeRevealedCards[2] = {-1, -1};
        -:   42:			//tribute_func_test(&G, 0, 1, tributeRevealedCards);
  1000000:   43:			playTribute_test(&G, 2);
call    0 returned 100%
        -:   44:		}
        -:   45:	}
        -:   46:
        1:   47:	return 0;
        -:   48:}
        -:   49:/*
        -:   50:int tribute_func_test(struct gameState *state, int currentPlayer, int nextPlayer, int *tributeRevealedCards) {
        -:   51:	int i = 0;
        -:   52:        if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
        -:   53:            if (state->deckCount[nextPlayer] > 0) {
        -:   54:                tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        -:   55:                state->deckCount[nextPlayer]--;
        -:   56:            }
        -:   57:            else if (state->discardCount[nextPlayer] > 0) {
        -:   58:                tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
        -:   59:                state->discardCount[nextPlayer]--;
        -:   60:            }
        -:   61:            else {
        -:   62:                //No Card to Reveal
        -:   63:                if (DEBUG) {
        -:   64:                    printf("No cards to reveal\n");
        -:   65:                }
        -:   66:            }
        -:   67:        }
        -:   68:
        -:   69:        else {
        -:   70:            if (state->deckCount[nextPlayer] == 0) {
        -:   71:                for (i = 0; i < state->discardCount[nextPlayer]; i++) {
        -:   72:                    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
        -:   73:                    state->deckCount[nextPlayer]++;
        -:   74:                    state->discard[nextPlayer][i] = -1;
        -:   75:                    state->discardCount[nextPlayer]--;
        -:   76:                }
        -:   77:
        -:   78:                shuffle(currentPlayer, state);//Shuffle the deck
        -:   79:            }
        -:   80:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        -:   81:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        -:   82:            state->deckCount[nextPlayer]--;
        -:   83:            tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        -:   84:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        -:   85:            state->deckCount[nextPlayer]--;
        -:   86:        }
        -:   87:
        -:   88:        if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
        -:   89:            state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        -:   90:            state->playedCardCount++;
        -:   91:            tributeRevealedCards[1] = -1;
        -:   92:        }
        -:   93:
        -:   94:        for (i = 0; i <= 2; i ++) {
        -:   95:            if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
        -:   96:                state->coins -= 2;
        -:   97:            }
        -:   98:
        -:   99:            else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
        -:  100:                drawCard(currentPlayer, state);
        -:  101:                drawCard(currentPlayer, state);
        -:  102:            }
        -:  103:            else { //Action Card
        -:  104:                state->numActions = state->numActions + 2;
        -:  105:            }
        -:  106:        }
        -:  107:
        -:  108:        return 0;
        -:  109:}
        -:  110:*/
        -:  111:
function playTribute_test called 1000000 returned 100% blocks executed 80%
  1000000:  112:int playTribute_test(struct gameState *state, int handPos) {
  1000000:  113:	int currentPlayer = 0;
  1000000:  114:    int nextPlayer = currentPlayer + 1;
  1000000:  115:	int tributeRevealedCards[2] = {-1, -1};
        -:  116:	int i;
        -:  117:	
  1000000:  118:	if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   997062:  119:		if (state->deckCount[nextPlayer] > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  120:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  121:			state->deckCount[nextPlayer]--;
        -:  122:		}
   997062:  123:		else if (state->discardCount[nextPlayer] > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  124:			tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  125:			state->discardCount[nextPlayer]--;
        -:  126:		}
        -:  127:		else {
        -:  128:			//No Card to Reveal
        -:  129:			if (DEBUG) {
        -:  130:				printf("No cards to reveal\n");
        -:  131:			}
        -:  132:		}
        -:  133:	}
        -:  134:
        -:  135:	else {
     2938:  136:		if (state->deckCount[nextPlayer] == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  137:			for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  138:				state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  139:				state->deckCount[nextPlayer]++;
    #####:  140:				state->discard[nextPlayer][i] = -1;
    #####:  141:				state->discardCount[nextPlayer]--;
        -:  142:			}
        -:  143:
    #####:  144:			shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -:  145:		}
     2938:  146:		tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     2938:  147:		state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     2938:  148:		state->deckCount[nextPlayer]--;
     2938:  149:		tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
     2938:  150:		state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
     2938:  151:		state->deckCount[nextPlayer]--;
        -:  152:	}
        -:  153:
  1000000:  154:	if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   998109:  155:		state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
   998109:  156:		state->playedCardCount++;
   998109:  157:		tributeRevealedCards[1] = -1;
        -:  158:	}
        -:  159:
  4000000:  160:	for (i = 0; i <= 2; i ++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
  3000000:  161:		if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     2519:  162:			state->coins += 3; //BUG! Should be 2, not 3
        -:  163:		}
        -:  164:
  2997481:  165:		else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
     1340:  166:			drawCard(currentPlayer, state);
call    0 returned 100%
     1340:  167:			drawCard(currentPlayer, state);
call    0 returned 100%
        -:  168:		}
        -:  169:		else { //Action Card
  2996141:  170:			state->numActions = state->numActions + 1; //BUG! Should add 2 Actions, not just 1
        -:  171:		}
        -:  172:	}
        -:  173:
  1000000:  174:	return 0;
        -:  175:}
